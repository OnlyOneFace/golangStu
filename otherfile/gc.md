# golang的垃圾回收（GC）机制
golang的垃圾回收采用的是 标记-清理（Mark-and-Sweep） 算法，
就是先标记出需要回收的内存对象快，然后在清理掉
## 那么这个GC算法如何调度的？
GC会导致 stw (stop the world)的问题，中断用户逻辑

**触发GC机制**
1.  在申请内存的时候，检查当前当前已分配的内存是否大于上次GC后的内存的2倍，若是则触发（主GC线程为当前M）
2.  监控线程发现上次GC的时间已经超过两分钟了，触发；将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M）

 **每当触发的时候，在主GC线程中就会走如下的GC流程**：
1.  stop the world，等待所有的M休眠；此时所有的业务逻辑代码都停止
2.  标记：分配gc标记任务，唤醒 gcproc个 M（就是第一步休眠的那些），分别做这个，直到所有的M都做完，才结束；并且所有M再次进入休眠
3.  清理：有一个单独的goroutine去清理已经标记的内存对象快
4.  start the world，设置gcwaiting=0，唤醒所有的M（不会超过P个数）

**对于上面的三个步骤，分别解释**：

**step1: stop the world**：
1.  设置gcwaiting=1，这个在每一个G任务之前会检查一次这个状态，如是，则会将当前M休眠；
2.  如果这个M里面正在运行一个长时间的G任务，咋办呢，难道会等待这个G任务自己切换吗？这样的话可要等10ms啊，不能等！坚决不能等！
所以会主动发出抢占标记（类似于上一篇），让当前G任务中断，再运行下一个G任务的时候，就会走到第1步
3.  一直等待所有的M进入休眠，此时所有的业务逻辑代码都停止

**step2: 标记**：
1.  根据gcproc的个数，分配成gcproc任务段；唤醒gcproc-1个M来执行（当前M也算一个）
2.  对于一个M，唤醒前设置它的helpgc标记，唤醒之后这个M会立马判断这个标记，如是，则开始做分配给自己的标记任务，如果先做完了，就会从别的M里面找一些来做
3.  等每一个M都做完，会再次进入休眠

**step3: 清理**：
1.  通过设置参数，可以以一个单独goroutine  运行，这个功能是在1.3版本之后增加的，这样的话就直接到下一步了，清理过程不是stw的
2.  也可以串行的在主GC线程执行；这样的话则清理过程也是stw的，

**step4: start the world**：
1.  设置gcwaiting=0
2.  唤醒P个M来继续做G任务（此时没有helpgc标记），业务逻辑代码开始