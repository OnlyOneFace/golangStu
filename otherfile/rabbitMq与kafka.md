# rabbitMQ
rabbitMQ详情见：https://www.sojson.com/blog/48.html
##RabbitMQ 选型和对比
1.  **从社区活跃度**
按照目前网络上的资料，RabbitMQ 、activeM 、ZeroMQ 三者中，综合来看，RabbitMQ 是首选。
2.  **持久化消息比较**
ZeroMq 不支持，ActiveMq 和RabbitMq 都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。
3.  **综合技术实现**
可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。
RabbitMq / Kafka 最好，ActiveMq 次之，ZeroMq 最差。当然ZeroMq 也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。
4.  **高并发**
毋庸置疑，RabbitMQ 最高，原因是它的实现语言是天生具备高并发高可用的erlang 语言。
5.  **比较关注的比较** RabbitMQ 和 Kafka
RabbitMq 比Kafka 成熟，在可用性上，稳定性上，可靠性上，  RabbitMq  胜于  Kafka  （理论上）。
6.  Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择 RabbitMq 。
7.  Kafka 的性能（吞吐量、TPS ）比RabbitMq 要高出来很多。

## rabbitMQ的优点
1.   **解耦**，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦
2.   **异步**，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度
3.   **削峰**，并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常
## rabbitMQ的缺点
1.  **系统可用性降低**：消息队列挂，系统就挂掉
2.  **系统复杂性增加**：要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。
## rabbitMQ问题处理
1.  **如何确保消息正确地发送至RabbitMQ？**
    
    rabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。
    ```text
    发送方确认模式: 将信道设置成confirm模式，则所有在信道上发布的消息都会被指定一个唯一ID。
    一旦消息被投递到目标队列或者消息被写入磁盘后，信道会发送一个确认给生产者。
    如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。
    发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。
    当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。
    ```
2.  **如何确保消息接收方消费了消息？**

    接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。
    只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。
    这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。
    
    几种特殊情况：
    1.  如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）
        
        重复消费隐患的解决方案：将消费的消息存入redis，每次消费前确认消费的信息是否存在。不存在说明，没有消费，存在说明消费了但没有发送确认
    2.  如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息
3.  **如何避免消息重复投递或重复消费？**
    
    在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；
    在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费
    
    这个问题针对业务场景来答分以下几点：
    1.  拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据
    2.  拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作
    3.  准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将<id,message>以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可
4.  **如何解决丢数据的问题?如何解决丢数据的问题?**

    **生产者**：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。
                transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。
                **缺点**：吞吐量下降
                
    **消息队列**：开启持久化配置。
                持久化配置可以和confirm机制配合使用，在消息持久化磁盘后，给生产者发送一个Ack信号。
                这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。
                
    **消费者**：
    1.  自动确认模式：消费者挂掉，待ack的消息回归到队列中。
                    消费者抛出异常，消息会不断的被重发，直到处理成功。
                    不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试
    2.  手动确认模式：如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者。
                    如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常。
                    如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。
    3.  不确认模式：只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发
                
    